{
  "PRINT": {
    "syntax": "PRINT [expression [;|,] ...]",
    "category": "io",
    "params": {
      "expression": {
        "type": "string|number",
        "optional": true
      }
    },
    "description": "Outputs text or numbers to the screen",
    "common_mistakes": [
      "Forgetting semicolon causes newline",
      "Comma advances to next tab position (10 char intervals)"
    ],
    "examples": [
      "PRINT \"HELLO\"",
      "PRINT A; B; C",
      "PRINT \"SCORE:\"; SCORE"
    ],
    "since": "BASIC V2"
  },
  "POKE": {
    "syntax": "POKE address, value",
    "category": "memory",
    "params": {
      "address": {
        "type": "integer",
        "range": [0, 65535]
      },
      "value": {
        "type": "integer",
        "range": [0, 255]
      }
    },
    "description": "Writes a byte value to memory address",
    "common_mistakes": [
      "POKE without comma separator",
      "Value > 255 causes ILLEGAL QUANTITY ERROR",
      "Poking wrong addresses can crash system"
    ],
    "examples": [
      "POKE 53280,0 : REM BLACK BORDER",
      "POKE 53281,1 : REM WHITE BACKGROUND",
      "POKE 1024,1 : REM PUT 'A' AT TOP LEFT"
    ],
    "since": "BASIC V2"
  },
  "PEEK": {
    "syntax": "PEEK(address)",
    "category": "memory",
    "params": {
      "address": {
        "type": "integer",
        "range": [0, 65535]
      }
    },
    "returns": "integer",
    "description": "Reads a byte value from memory address",
    "common_mistakes": [
      "Parentheses are required",
      "Returns value 0-255, not multi-byte values"
    ],
    "examples": [
      "A = PEEK(53280) : REM READ BORDER COLOR",
      "IF PEEK(197) <> 64 THEN 100 : REM KEY PRESSED"
    ],
    "since": "BASIC V2"
  },
  "FOR": {
    "syntax": "FOR variable = start TO end [STEP increment]",
    "category": "control",
    "params": {
      "variable": {
        "type": "numeric-variable"
      },
      "start": {
        "type": "number"
      },
      "end": {
        "type": "number"
      },
      "increment": {
        "type": "number",
        "optional": true,
        "default": 1
      }
    },
    "description": "Begins a loop that counts from start to end",
    "common_mistakes": [
      "Forgetting NEXT statement causes SYNTAX ERROR",
      "Variable in NEXT must match FOR variable",
      "Nested loops must have different variables"
    ],
    "examples": [
      "FOR I=1 TO 10",
      "FOR X=0 TO 39 STEP 2",
      "FOR T=100 TO 1 STEP -1"
    ],
    "requires": ["NEXT"],
    "since": "BASIC V2"
  },
  "NEXT": {
    "syntax": "NEXT [variable]",
    "category": "control",
    "params": {
      "variable": {
        "type": "numeric-variable",
        "optional": true
      }
    },
    "description": "Marks end of FOR loop",
    "common_mistakes": [
      "Variable should match FOR variable for clarity",
      "Missing NEXT causes SYNTAX ERROR on RUN"
    ],
    "examples": [
      "NEXT I",
      "NEXT",
      "NEXT X"
    ],
    "requires": ["FOR"],
    "since": "BASIC V2"
  },
  "IF": {
    "syntax": "IF condition THEN statement",
    "category": "control",
    "params": {
      "condition": {
        "type": "boolean-expression"
      },
      "statement": {
        "type": "line-number|statement"
      }
    },
    "description": "Executes statement if condition is true",
    "common_mistakes": [
      "ELSE doesn't exist in BASIC V2",
      "Multiple statements require THEN line-number",
      "String comparisons are case-sensitive"
    ],
    "examples": [
      "IF A=10 THEN PRINT \"TEN\"",
      "IF X>100 THEN 500",
      "IF A$=\"YES\" THEN GOSUB 1000"
    ],
    "requires": ["THEN"],
    "since": "BASIC V2"
  },
  "THEN": {
    "syntax": "IF condition THEN statement",
    "category": "control",
    "params": {
      "statement": {
        "type": "line-number|statement"
      }
    },
    "description": "Part of IF statement, executes statement if condition is true",
    "common_mistakes": [
      "Cannot use THEN without IF",
      "THEN line-number jumps to line, THEN statement executes inline"
    ],
    "examples": [
      "IF A=10 THEN PRINT \"TEN\"",
      "IF X>100 THEN 500"
    ],
    "requires": ["IF"],
    "since": "BASIC V2"
  },
  "GOTO": {
    "syntax": "GOTO line-number",
    "category": "control",
    "params": {
      "line-number": {
        "type": "integer",
        "range": [0, 63999]
      }
    },
    "description": "Jumps to specified line number",
    "common_mistakes": [
      "Jumping to non-existent line causes UNDEF'D STATEMENT ERROR",
      "Excessive GOTO creates spaghetti code"
    ],
    "examples": [
      "GOTO 100",
      "IF A=0 THEN GOTO 500"
    ],
    "since": "BASIC V2"
  },
  "GOSUB": {
    "syntax": "GOSUB line-number",
    "category": "control",
    "params": {
      "line-number": {
        "type": "integer",
        "range": [0, 63999]
      }
    },
    "description": "Calls subroutine at line number",
    "common_mistakes": [
      "Subroutine must end with RETURN",
      "Forgetting RETURN causes program to continue",
      "Too many nested GOSUBs (>23) causes OUT OF MEMORY"
    ],
    "examples": [
      "GOSUB 1000",
      "IF SCORE>100 THEN GOSUB 2000"
    ],
    "requires": ["RETURN"],
    "since": "BASIC V2"
  },
  "RETURN": {
    "syntax": "RETURN",
    "category": "control",
    "description": "Returns from GOSUB subroutine",
    "common_mistakes": [
      "RETURN without GOSUB causes RETURN WITHOUT GOSUB ERROR",
      "Jumping into middle of subroutine breaks RETURN"
    ],
    "examples": [
      "RETURN"
    ],
    "requires": ["GOSUB"],
    "since": "BASIC V2"
  },
  "ON": {
    "syntax": "ON expression GOTO|GOSUB line1[, line2, line3...]",
    "category": "control",
    "params": {
      "expression": {
        "type": "integer",
        "description": "Value determines which line to jump to (1=first, 2=second, etc)"
      },
      "line": {
        "type": "integer",
        "range": [0, 63999]
      }
    },
    "description": "Multi-way branch based on expression value",
    "common_mistakes": [
      "Expression < 1 or > number of lines causes next statement to execute",
      "Expression must be integer, not string",
      "Can use ON...GOTO for jumps or ON...GOSUB for subroutine calls"
    ],
    "examples": [
      "ON X GOTO 100, 200, 300",
      "ON MENU GOSUB 1000, 2000, 3000",
      "ON INT(RND(1)*3)+1 GOTO 10, 20, 30"
    ],
    "requires": ["GOTO", "GOSUB"],
    "since": "BASIC V2"
  },
  "REM": {
    "syntax": "REM comment",
    "category": "utility",
    "params": {
      "comment": {
        "type": "text"
      }
    },
    "description": "Comment line, ignored by interpreter",
    "common_mistakes": [
      "REM slows program execution (still stored in memory)",
      "Everything after REM is ignored, even valid BASIC"
    ],
    "examples": [
      "REM THIS IS A COMMENT",
      "10 REM INITIALIZE VARIABLES"
    ],
    "since": "BASIC V2"
  },
  "AND": {
    "syntax": "expression AND expression",
    "category": "operator",
    "params": {
      "expression": {
        "type": "number"
      }
    },
    "returns": "number",
    "description": "Bitwise AND operation (also logical AND for comparisons)",
    "common_mistakes": [
      "Not boolean-only, also does bitwise operations",
      "Operator precedence can surprise (use parentheses)"
    ],
    "examples": [
      "IF A>5 AND B<10 THEN 100",
      "C = A AND B : REM BITWISE",
      "IF (X=1 AND Y=2) OR Z=3 THEN 200"
    ],
    "since": "BASIC V2"
  },
  "OR": {
    "syntax": "expression OR expression",
    "category": "operator",
    "params": {
      "expression": {
        "type": "number"
      }
    },
    "returns": "number",
    "description": "Bitwise OR operation (also logical OR for comparisons)",
    "common_mistakes": [
      "Not boolean-only, also does bitwise operations",
      "Operator precedence can surprise (use parentheses)"
    ],
    "examples": [
      "IF A=1 OR B=2 THEN 100",
      "C = A OR B : REM BITWISE",
      "IF X<0 OR X>39 THEN 500"
    ],
    "since": "BASIC V2"
  },
  "END": {
    "syntax": "END",
    "category": "control",
    "description": "Terminates program execution",
    "common_mistakes": [
      "Not required but good practice",
      "Program stops when reaching END or end of code"
    ],
    "examples": [
      "END"
    ],
    "since": "BASIC V2"
  },
  "STOP": {
    "syntax": "STOP",
    "category": "control",
    "description": "Pauses program execution, displays BREAK message",
    "common_mistakes": [
      "Unlike END, allows CONT to resume",
      "Often used for debugging"
    ],
    "examples": [
      "STOP",
      "IF ERROR THEN STOP"
    ],
    "since": "BASIC V2"
  },
  "READ": {
    "syntax": "READ variable[, variable...]",
    "category": "io",
    "params": {
      "variable": {
        "type": "variable"
      }
    },
    "description": "Reads values from DATA statements",
    "common_mistakes": [
      "Must have matching DATA statements",
      "OUT OF DATA ERROR if no data left"
    ],
    "examples": [
      "READ A",
      "READ X, Y, Z"
    ],
    "requires": ["DATA"],
    "since": "BASIC V2"
  },
  "DATA": {
    "syntax": "DATA value[, value...]",
    "category": "io",
    "params": {
      "value": {
        "type": "number|string"
      }
    },
    "description": "Stores data values for READ statements",
    "common_mistakes": [
      "Strings don't need quotes unless they contain commas",
      "Data is read sequentially across all DATA statements"
    ],
    "examples": [
      "DATA 10, 20, 30",
      "DATA HELLO, WORLD"
    ],
    "requires": ["READ"],
    "since": "BASIC V2"
  },
  "RESTORE": {
    "syntax": "RESTORE [line_number]",
    "category": "control",
    "params": {
      "line_number": {
        "type": "integer",
        "optional": true
      }
    },
    "description": "Resets DATA pointer to first DATA statement or specified line",
    "common_mistakes": [
      "Without line number, resets to first DATA statement",
      "With line number, sets to DATA statement at that line",
      "Useful for re-reading DATA multiple times"
    ],
    "examples": [
      "RESTORE",
      "RESTORE 1000",
      "FOR I=1 TO 10: READ A: PRINT A: NEXT: RESTORE"
    ],
    "requires": ["DATA", "READ"],
    "since": "BASIC V2"
  },
  "INPUT": {
    "syntax": "INPUT [prompt;] variable[, variable...]",
    "category": "io",
    "params": {
      "prompt": {
        "type": "string",
        "optional": true
      },
      "variable": {
        "type": "variable"
      }
    },
    "description": "Waits for user input from keyboard",
    "common_mistakes": [
      "Semicolon after prompt removes the '?' character",
      "Type mismatch error if entering wrong data type"
    ],
    "examples": [
      "INPUT A",
      "INPUT \"NAME\"; N$",
      "INPUT \"X,Y\"; X, Y"
    ],
    "since": "BASIC V2"
  },
  "GET": {
    "syntax": "GET variable",
    "category": "io",
    "params": {
      "variable": {
        "type": "string-variable"
      }
    },
    "description": "Gets single character from keyboard without waiting",
    "common_mistakes": [
      "Returns empty string if no key pressed",
      "Must be in loop to catch key press"
    ],
    "examples": [
      "GET K$",
      "IF K$=\"\" THEN 100"
    ],
    "since": "BASIC V2"
  },
  "SYS": {
    "syntax": "SYS address",
    "category": "system",
    "params": {
      "address": {
        "type": "integer",
        "range": [0, 65535]
      }
    },
    "description": "Calls machine language routine at address",
    "common_mistakes": [
      "Calling wrong address can crash system",
      "Must know what routine expects"
    ],
    "examples": [
      "SYS 64738 : REM CLEAR SCREEN"
    ],
    "since": "BASIC V2"
  },
  "LET": {
    "syntax": "LET variable = expression",
    "category": "assignment",
    "params": {
      "variable": {
        "type": "variable"
      },
      "expression": {
        "type": "any"
      }
    },
    "description": "Assigns value to variable (optional keyword)",
    "common_mistakes": [
      "LET is optional in BASIC V2",
      "Most programmers omit it"
    ],
    "examples": [
      "LET A = 10",
      "A = 10"
    ],
    "since": "BASIC V2"
  },
  "DIM": {
    "syntax": "DIM array(size[, size...])",
    "category": "memory",
    "params": {
      "array": {
        "type": "array-variable"
      },
      "size": {
        "type": "integer"
      }
    },
    "description": "Declares array dimensions",
    "common_mistakes": [
      "Default arrays are 0-10 without DIM",
      "Cannot redimension after first use"
    ],
    "examples": [
      "DIM A(20)",
      "DIM B%(100,100)"
    ],
    "since": "BASIC V2"
  },
  "NEW": {
    "syntax": "NEW",
    "category": "utility",
    "description": "Erases program in memory",
    "common_mistakes": [
      "Cannot be undone",
      "Doesn't affect disk files"
    ],
    "examples": [
      "NEW"
    ],
    "since": "BASIC V2"
  },
  "LIST": {
    "syntax": "LIST [start[-end]]",
    "category": "utility",
    "params": {
      "start": {
        "type": "integer",
        "optional": true
      },
      "end": {
        "type": "integer",
        "optional": true
      }
    },
    "description": "Displays program listing",
    "common_mistakes": [
      "LIST without args shows whole program",
      "Can specify range: LIST 100-200"
    ],
    "examples": [
      "LIST",
      "LIST 100",
      "LIST 100-200"
    ],
    "since": "BASIC V2"
  },
  "RUN": {
    "syntax": "RUN [line-number]",
    "category": "utility",
    "params": {
      "line-number": {
        "type": "integer",
        "optional": true
      }
    },
    "description": "Executes program",
    "common_mistakes": [
      "Clears all variables",
      "Optional line number starts execution there"
    ],
    "examples": [
      "RUN",
      "RUN 100"
    ],
    "since": "BASIC V2"
  },
  "LOAD": {
    "syntax": "LOAD \"filename\" [, device [, secondary]]",
    "category": "io",
    "params": {
      "filename": {
        "type": "string"
      },
      "device": {
        "type": "integer",
        "optional": true,
        "default": 8
      },
      "secondary": {
        "type": "integer",
        "optional": true
      }
    },
    "description": "Loads program from disk",
    "common_mistakes": [
      "Device 8 is disk drive",
      "Secondary address 1 loads to address in file"
    ],
    "examples": [
      "LOAD \"GAME\"",
      "LOAD \"*\", 8, 1"
    ],
    "since": "BASIC V2"
  },
  "SAVE": {
    "syntax": "SAVE \"filename\" [, device]",
    "category": "io",
    "params": {
      "filename": {
        "type": "string"
      },
      "device": {
        "type": "integer",
        "optional": true,
        "default": 8
      }
    },
    "description": "Saves program to disk",
    "common_mistakes": [
      "Overwrites existing file with same name",
      "Device 8 is disk drive"
    ],
    "examples": [
      "SAVE \"GAME\"",
      "SAVE \"BACKUP\", 8"
    ],
    "since": "BASIC V2"
  },
  "CLR": {
    "syntax": "CLR",
    "category": "utility",
    "description": "Clears all variables",
    "common_mistakes": [
      "Doesn't erase program",
      "Also resets DATA pointer"
    ],
    "examples": [
      "CLR"
    ],
    "since": "BASIC V2"
  },
  "OPEN": {
    "syntax": "OPEN logical_file, device, secondary [, \"filename\"]",
    "category": "io",
    "params": {
      "logical_file": {
        "type": "integer",
        "range": [1, 255],
        "description": "Logical file number for future reference"
      },
      "device": {
        "type": "integer",
        "description": "Device number (8=disk, 4=printer, etc.)"
      },
      "secondary": {
        "type": "integer",
        "description": "Secondary address/channel"
      },
      "filename": {
        "type": "string",
        "optional": true,
        "description": "Filename for disk operations"
      }
    },
    "description": "Opens file or device for input/output",
    "common_mistakes": [
      "Must CLOSE file when done",
      "Forgetting comma after secondary address",
      "Using same logical file number twice"
    ],
    "examples": [
      "OPEN 1,8,2,\"DATA,S,W\"",
      "OPEN 2,4",
      "OPEN 15,8,15"
    ],
    "since": "BASIC V2"
  },
  "CLOSE": {
    "syntax": "CLOSE logical_file",
    "category": "io",
    "params": {
      "logical_file": {
        "type": "integer",
        "range": [1, 255]
      }
    },
    "description": "Closes previously opened file",
    "common_mistakes": [
      "Forgetting to CLOSE causes file corruption",
      "Closing unopened file has no effect"
    ],
    "examples": [
      "CLOSE 1",
      "CLOSE 15"
    ],
    "requires": ["OPEN"],
    "since": "BASIC V2"
  },
  "PRINT#": {
    "syntax": "PRINT#logical_file, expression [; expression...]",
    "category": "io",
    "params": {
      "logical_file": {
        "type": "integer",
        "range": [1, 255]
      },
      "expression": {
        "type": "string|number"
      }
    },
    "description": "Writes data to opened file",
    "common_mistakes": [
      "File must be OPENed first",
      "Semicolon suppresses newline like regular PRINT",
      "Use CHR$(13) for explicit carriage return"
    ],
    "examples": [
      "PRINT#1,NAME$",
      "PRINT#1,NAME$;\",\";SCORE",
      "PRINT#2,\"DATA:\";X;Y;Z"
    ],
    "requires": ["OPEN"],
    "since": "BASIC V2"
  },
  "FRE": {
    "syntax": "FRE(dummy)",
    "category": "utility",
    "params": {
      "dummy": {
        "type": "number",
        "description": "Dummy argument (typically 0), triggers garbage collection if string"
      }
    },
    "returns": "integer",
    "description": "Returns number of free BASIC memory bytes",
    "common_mistakes": [
      "FRE(0) returns available memory without garbage collection",
      "FRE(\"\") forces garbage collection first, then returns free memory",
      "Useful for detecting memory pressure"
    ],
    "examples": [
      "F=FRE(0)",
      "PRINT \"FREE:\";FRE(0)",
      "IF FRE(0)<1000 THEN PRINT \"LOW MEMORY\""
    ],
    "since": "BASIC V2"
  },
  "ERR": {
    "syntax": "ERR",
    "category": "error",
    "returns": "integer",
    "description": "Returns error code of last error (used with ON ERROR GOTO)",
    "common_mistakes": [
      "Only valid after an error has occurred",
      "Error codes: 1=TOO MANY FILES, 2=FILE OPEN, 4=FILE NOT FOUND, etc.",
      "ERR is cleared when RESUME executes"
    ],
    "examples": [
      "PRINT ERR",
      "IF ERR=4 THEN PRINT \"FILE NOT FOUND\"",
      "ON ERROR GOTO 900: ... 900 PRINT \"ERROR\";ERR"
    ],
    "requires": ["ON ERROR GOTO"],
    "since": "BASIC V2"
  },
  "ERL": {
    "syntax": "ERL",
    "category": "error",
    "returns": "integer",
    "description": "Returns line number where last error occurred (used with ON ERROR GOTO)",
    "common_mistakes": [
      "Only valid after an error has occurred",
      "Returns 0 if error in direct mode",
      "ERL is cleared when RESUME executes"
    ],
    "examples": [
      "PRINT ERL",
      "PRINT \"ERROR AT LINE\";ERL",
      "ON ERROR GOTO 900: ... 900 PRINT \"LINE\";ERL;\"ERR\";ERR"
    ],
    "requires": ["ON ERROR GOTO"],
    "since": "BASIC V2"
  },
  "RESUME": {
    "syntax": "RESUME [NEXT|line-number]",
    "category": "error",
    "params": {
      "target": {
        "type": "NEXT|line-number",
        "optional": true,
        "description": "RESUME=retry same line, RESUME NEXT=continue after error, RESUME n=jump to line"
      }
    },
    "description": "Continues program execution after error handler (used with ON ERROR GOTO)",
    "common_mistakes": [
      "RESUME retries the line that caused the error",
      "RESUME NEXT continues at next statement after error",
      "RESUME n jumps to specific line number",
      "Using RESUME without ON ERROR GOTO causes error"
    ],
    "examples": [
      "RESUME",
      "RESUME NEXT",
      "RESUME 100"
    ],
    "requires": ["ON ERROR GOTO"],
    "since": "BASIC V2"
  }
}
